name: Debug Workflow

on:
  workflow_dispatch:
    inputs:
      test_number:
        description: "Phone number to test (e.g., 081234567890)"
        required: true
        default: "081234567890"
      headless:
        description: "Run in headless mode"
        required: true
        default: true
        type: boolean

jobs:
  debug:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y software-properties-common
          sudo add-apt-repository universe
          sudo apt-get update
          sudo apt-get install -y \
            libnss3 \
            libnspr4 \
            libatk1.0-0 \
            libatk-bridge2.0-0 \
            libcups2 \
            libdrm2 \
            libxkbcommon0 \
            libxcomposite1 \
            libxdamage1 \
            libxfixes3 \
            libxrandr2 \
            libgbm1 \
            libpulse0 \
            libwayland-client0 \
            libwayland-cursor0 \
            libwayland-egl1 \
            libwayland-server0 \
            libx11-xcb1 \
            libxcb-dri3-0 \
            libxcb-icccm4 \
            libxcb-image0 \
            libxcb-keysyms1 \
            libxcb-randr0 \
            libxcb-render-util0 \
            libxcb-shape0 \
            libxcb-util1 \
            libxcb-xfixes0 \
            libxcb-xinerama0 \
            libxcb-xkb1 \
            libxkbcommon-x11-0 \
            xvfb

      - name: Install Python dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install requests
          playwright install chromium --with-deps

      - name: Verify Playwright installation
        run: |
          python -c "
          from playwright.sync_api import sync_playwright
          with sync_playwright() as p:
              browser = p.chromium.launch()
              browser.close()
          print('‚úÖ Playwright verification successful')
          "

      - name: Create debug configuration
        run: |
          echo "DEBUG=true" >> .env
          echo "TEST_NUMBER=${{ github.event.inputs.test_number }}" >> .env
          echo "HEADLESS=${{ github.event.inputs.headless }}" >> .env

      - name: Modify debug script for CI
        run: |
          cat > scripts/checker_debug_ci.py << 'EOF'
          import asyncio
          import os
          import time
          from datetime import datetime
          from pathlib import Path
          from playwright.async_api import async_playwright, TimeoutError

          URL = "https://ceebydith.com/cek-hlr-lokasi-hp.html"
          MAX_RETRIES = 3

          def log_debug(message: str):
              """Helper function untuk print debug message dengan timestamp"""
              timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
              print(f"[DEBUG {timestamp}] {message}")

          async def check_number(page, msisdn: str) -> dict:
              """Cek 1 nomor di halaman HLR lookup dengan debug messages yang detail"""
              log_debug(f"üåê Membuka URL: {URL}")
              
              for attempt in range(MAX_RETRIES):
                  try:
                      log_debug(f"‚è≥ Mencoba membuka halaman (attempt {attempt + 1}/{MAX_RETRIES})...")
                      
                      # Use networkidle to ensure all resources are loaded
                      await page.goto(URL, 
                                    wait_until="networkidle",
                                    timeout=60000)
                      
                      log_debug("‚è≥ Menunggu halaman siap...")
                      # Wait for specific elements that indicate page is ready
                      await page.wait_for_load_state("domcontentloaded")
                      await page.wait_for_load_state("load")
                      await page.wait_for_load_state("networkidle")
                      
                      # Additional wait to ensure JavaScript execution
                      await page.wait_for_timeout(2000)
                      
                      log_debug("‚úÖ Halaman berhasil dimuat")
                      
                      # Screenshot halaman awal
                      await page.screenshot(path=f"debug_initial_{attempt + 1}.png")
                      log_debug("üì∏ Screenshot awal disimpan")

                      # Debug page content and save
                      page_content = await page.content()
                      log_debug(f"üìÑ Page HTML length: {len(page_content)} bytes")
                      with open(f"debug_html_{attempt + 1}.txt", "w", encoding="utf-8") as f:
                          f.write(page_content)
                      
                      # Coba berbagai selector untuk input field
                      selectors = ["#msisdn", "[name='msisdn']", "input[type='text']"]
                      input_found = False
                      
                      for selector in selectors:
                          log_debug(f"üîç Mencari input field dengan selector: {selector}")
                          try:
                              # Wait for element with timeout
                              element = await page.wait_for_selector(selector, 
                                                                   state="visible",
                                                                   timeout=5000)
                              if element:
                                  input_found = True
                                  log_debug(f"‚úÖ Input field ditemukan dengan selector: {selector}")
                                  break
                          except:
                              continue
                      
                      if not input_found:
                          raise Exception("Input field tidak ditemukan dengan semua selector yang dicoba")
                      
                      # tunggu input aktif dengan timeout lebih lama
                      log_debug("‚è≥ Menunggu input field menjadi aktif...")
                      await page.wait_for_selector("#msisdn:not([disabled])", 
                                                 timeout=30000, 
                                                 state="visible")
                      log_debug("‚úÖ Input field sudah aktif dan visible")
                      
                      # Jika berhasil, keluar dari loop
                      break
                      
                  except Exception as e:
                      log_debug(f"‚ùå Error pada attempt {attempt + 1}: {str(e)}")
                      await page.screenshot(path=f"debug_error_load_{attempt + 1}.png")
                      
                      if attempt == MAX_RETRIES - 1:  # Jika ini attempt terakhir
                          log_debug("‚ùå Semua attempt gagal")
                          raise e
                      
                      # Tunggu sebentar sebelum mencoba lagi
                      await asyncio.sleep(5)

              # isi nomor
              log_debug(f"üìù Mengisi nomor: {msisdn}")
              await page.fill("#msisdn", msisdn)
              await page.screenshot(path="debug_filled.png")
              log_debug("‚úÖ Nomor berhasil diisi")

              # tunggu tombol aktif lalu klik
              log_debug("‚è≥ Menunggu tombol cek menjadi aktif...")
              await page.wait_for_selector("#find:not([disabled])", timeout=5000)
              log_debug("üñ±Ô∏è Mengklik tombol cek")
              await page.click("#find")

              # Screenshot setelah klik
              await page.screenshot(path="debug_after_click.png")

              # tunggu hasil
              log_debug("‚è≥ Menunggu hasil pengecekan...")
              try:
                  await page.wait_for_function(
                      """() => {
                          const el = document.querySelector("pre.message");
                          if (!el) return false;
                          const txt = el.innerText;
                          return txt.includes("Operator") || txt.includes("ERROR");
                      }""",
                      timeout=15000
                  )
                  text = await page.inner_text("pre.message")
                  log_debug("‚úÖ Hasil ditemukan")
                  log_debug(f"üìÑ Raw response:\n{text}")
                  
                  # Screenshot hasil
                  await page.screenshot(path="debug_result.png")
              except Exception as e:
                  log_debug(f"‚ö†Ô∏è Timeout untuk {msisdn}: {str(e)}")
                  await page.screenshot(path="debug_error.png")
                  return {"provider": None, "hlr": None, "raw_text": "", "error": str(e)}

              # parsing hasil
              provider, hlr = None, None
              for line in text.splitlines():
                  if "Operator" in line:
                      provider = line.split(":", 1)[1].strip()
                      log_debug(f"üì± Provider terdeteksi: {provider}")
                  elif "HLR" in line:
                      hlr = line.split(":", 1)[1].strip()
                      log_debug(f"üìç HLR terdeteksi: {hlr}")

              return {
                  "provider": provider,
                  "hlr": hlr,
                  "raw_text": text,
                  "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
              }

          async def run_debug_test():
              """Run debug test with CI parameters"""
              msisdn = os.getenv("TEST_NUMBER", "081234567890")
              headless = os.getenv("HEADLESS", "true").lower() == "true"
              
              log_debug(f"üöÄ Memulai debug test dengan nomor: {msisdn}")
              log_debug(f"üé≠ Mode headless: {headless}")
              
              try:
                  async with async_playwright() as p:
                      # Configure browser with necessary flags for CI environment
                      browser = await p.chromium.launch(
                          headless=headless,
                          args=[
                              '--no-sandbox',
                              '--disable-setuid-sandbox',
                              '--disable-dev-shm-usage',
                              '--disable-gpu',
                              '--no-first-run',
                              '--no-zygote',
                              '--single-process',
                              '--disable-extensions'
                          ]
                      )
                      
                      # Create new page with additional options
                      page = await browser.new_page(
                          user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/116.0.0.0 Safari/537.36",
                          viewport={'width': 1280, 'height': 720}
                      )
                      
                      # Set default timeouts
                      page.set_default_timeout(30000)
                      page.set_default_navigation_timeout(30000)
                      
                      result = await check_number(page, msisdn)
                      
                      log_debug("\n=== HASIL PENGECEKAN ===")
                      log_debug(f"üì± Provider: {result['provider']}")
                      log_debug(f"üìç HLR: {result['hlr']}")
                      log_debug(f"‚è∞ Waktu: {result['timestamp']}")
                      log_debug("=====================")
                      
                      await browser.close()
                      
                      # Save results to file
                      with open("debug_results.txt", "w") as f:
                          f.write(f"Test Number: {msisdn}\n")
                          f.write(f"Timestamp: {result['timestamp']}\n")
                          f.write(f"Provider: {result['provider']}\n")
                          f.write(f"HLR: {result['hlr']}\n")
                          f.write(f"\nRaw Response:\n{result['raw_text']}")
                      
                      return result
                      
              except Exception as e:
                  log_debug(f"‚ùå Error dalam test: {str(e)}")
                  with open("debug_error.txt", "w") as f:
                      f.write(f"Error: {str(e)}")
                  raise e

          if __name__ == "__main__":
              asyncio.run(run_debug_test())
          EOF

      - name: Run debug test
        run: python scripts/checker_debug_ci.py

      - name: Upload debug artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: debug-artifacts
          path: |
            debug_*.png
            debug_*.txt
          retention-days: 7
